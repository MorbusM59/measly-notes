import { app, BrowserWindow, ipcMain, session, shell } from 'electron';
import {
  initDatabase, createNote, getAllNotes, updateNote, updateNoteTitle, deleteNote,
  getNoteById, closeDatabase, updateNoteFilePath, getNotesPage,
  addTagToNote, removeTagFromNote, reorderNoteTags, getNoteTags,
  getAllTags, getTopTags, searchNotesByTag, getNotesByPrimaryTag, getCategoryHierarchy, getLastEditedNote,
  upsertNoteFts, removeNoteFts, searchNotes
} from './main/database';
import { initFileSystem, saveNoteContent, loadNoteContent, deleteNoteFile } from './main/fileSystem';
import { SearchResult } from './shared/types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Basic validators for main-side IPC defense-in-depth
function isString(v: unknown): v is string {
  return typeof v === 'string';
}
function isNonEmptyString(v: unknown): v is string {
  return isString(v) && v.trim().length > 0;
}
function isPositiveInteger(v: unknown): v is number {
  return typeof v === 'number' && Number.isInteger(v) && v >= 0;
}
function isStringArray(v: unknown): v is string[] {
  return Array.isArray(v) && v.every(i => typeof i === 'string');
}

// Global error handlers to make crashes visible in the terminal
process.on('uncaughtException', (err) => {
  console.error('[main] uncaughtException', err && err.stack ? err.stack : err);
});
process.on('unhandledRejection', (reason) => {
  console.error('[main] unhandledRejection', reason && (reason as any).stack ? (reason as any).stack : reason);
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
try {
  if (require('electron-squirrel-startup')) {
    app.quit();
  }
} catch (err) {
  // in some environments require may behave differently; log and continue
  console.warn('[main] squirrel check failed:', err);
}

// Disable GPU hardware acceleration to prevent GPU process crashes on Windows.
app.disableHardwareAcceleration();

let mainWindow: BrowserWindow | null = null;

// Compute internal hostnames (app origin + localhost variants) so we can block opening those externally
function getInternalHostnames(): Set<string> {
  const hosts = new Set<string>(['localhost', '127.0.0.1', '::1']);
  try {
    if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
      const u = new URL(MAIN_WINDOW_WEBPACK_ENTRY);
      if (u.hostname) hosts.add(u.hostname);
    }
  } catch (_) {
    // ignore parsing errors
  }
  return hosts;
}

// Helper: decide whether a given URL should be opened in the external browser
function shouldOpenExternally(urlStr: string, internalHosts: Set<string>): boolean {
  if (!urlStr) return false;
  let parsed: URL;
  try {
    parsed = new URL(urlStr);
  } catch (err) {
    // non-HTTP URL or invalid, do not open externally
    return false;
  }

  const protocol = parsed.protocol.toLowerCase();
  if (protocol !== 'http:' && protocol !== 'https:') {
    return false;
  }

  const hostname = parsed.hostname;
  // If hostname is one of our internal hosts (dev server / localhost), do NOT open externally
  if (internalHosts.has(hostname)) return false;

  // Otherwise treat as external
  return true;
}

const createWindow = (): void => {
  console.log('[main] createWindow() - start');
  try {
    mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        nodeIntegration: false,
        // enable Chromium spellchecker in the renderer
        spellcheck: true,
      },
      show: false, // show when ready-to-show
    });

    mainWindow.once('ready-to-show', () => {
      console.log('[main] mainWindow ready-to-show -> showing');
      try {
        mainWindow?.show();
      } catch (err) {
        console.error('[main] error showing window', err);
      }
    });

    // Prevent navigation and always open external links in the OS default browser,
    // but never open the app's own origin (dev server/localhost) externally.
    const internalHosts = getInternalHostnames();

    mainWindow.webContents.on('will-navigate', (event, url) => {
      // Always prevent in-app navigation; decide whether to open externally
      event.preventDefault();

      if (shouldOpenExternally(url, internalHosts)) {
        try {
          shell.openExternal(url);
          console.log('[main] opened external URL from will-navigate:', url);
        } catch (err) {
          console.warn('[main] failed to open external URL from will-navigate:', url, err);
        }
      } else {
        // blocked/internal navigation - do nothing
        console.log('[main] blocked internal navigation attempt to:', url);
      }
    });

    // setWindowOpenHandler or fallback
    try {
      const wcAny = mainWindow.webContents as any;
      if (wcAny && typeof wcAny.setWindowOpenHandler === 'function') {
        wcAny.setWindowOpenHandler(({ url }: { url: string }) => {
          if (shouldOpenExternally(url, internalHosts)) {
            try {
              shell.openExternal(url);
              console.log('[main] opened external URL from setWindowOpenHandler:', url);
            } catch (err) {
              console.warn('[main] failed to open external URL from setWindowOpenHandler:', url, err);
            }
          } else {
            console.log('[main] denied window.open to internal URL:', url);
          }
          return { action: 'deny' };
        });
      } else if (wcAny && typeof wcAny.on === 'function') {
        wcAny.on('new-window', (event: any, url: any) => {
          try {
            event.preventDefault();
          } catch (_) {}
          const urlStr = String(url || '');
          if (shouldOpenExternally(urlStr, internalHosts)) {
            try {
              shell.openExternal(urlStr);
              console.log('[main] opened external URL from new-window fallback:', urlStr);
            } catch (err) {
              console.warn('[main] failed to open external URL from new-window fallback:', urlStr, err);
            }
          } else {
            console.log('[main] denied new-window to internal URL:', urlStr);
          }
        });
      }
    } catch (err) {
      console.warn('[main] window-open handlers setup failed:', err);
    }

    mainWindow.on('closed', () => {
      console.log('[main] mainWindow closed');
      mainWindow = null;
    });

    console.log('[main] loading URL:', MAIN_WINDOW_WEBPACK_ENTRY);
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch(err => {
      console.error('[main] loadURL failed', err && err.stack ? err.stack : err);
    });

    if (process.env.NODE_ENV === 'development') {
      console.log('[main] opening devtools (development mode)');
      mainWindow.webContents.openDevTools();
    }

    console.log('[main] createWindow() - done');
  } catch (err) {
    console.error('[main] createWindow() threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }
};

// Helper: set default spellchecker languages (multiple)
async function setDefaultSpellCheckerLanguages(langs: string[]) {
  try {
    await session.defaultSession.setSpellCheckerLanguages(langs);

    if ((session.defaultSession as any).setSpellCheckerEnabled) {
      try {
        (session.defaultSession as any).setSpellCheckerEnabled(true);
      } catch (err) {
        console.warn('[main] could not setSpellCheckerEnabled:', err);
      }
    }

    console.log('[main] spellchecker languages set to:', langs);
  } catch (err) {
    console.warn('[main] failed to set spellchecker languages:', err);
  }
}

// Initialize app
app.whenReady().then(async () => {
  console.log('[main] app.whenReady started');
  try {
    await initDatabase();
    console.log('[main] initDatabase OK');
    await initFileSystem();
    console.log('[main] initFileSystem OK');

    // Ensure English and German spellchecking are set by default on every machine.
    await setDefaultSpellCheckerLanguages(['en-US', 'de-DE']);

    // Block outgoing http(s) requests initiated by the renderer, but whitelist local/dev hosts
    try {
      const whitelistHostnames = getInternalHostnames();
      try {
        if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
          const mainHost = new URL(MAIN_WINDOW_WEBPACK_ENTRY).hostname;
          whitelistHostnames.add(mainHost);
        }
      } catch (_) {}

      session.defaultSession.webRequest.onBeforeRequest({ urls: ['http://*/*', 'https://*/*'] }, (details: any, callback: (response: { cancel: boolean }) => void) => {
        try {
          const urlStr: string = details.url || '';
          if (urlStr.startsWith('file:')) {
            return callback({ cancel: false });
          }
          let hostname = '';
          try {
            hostname = new URL(urlStr).hostname;
          } catch (err) {
            return callback({ cancel: true });
          }
          if (whitelistHostnames.has(hostname)) {
            return callback({ cancel: false });
          }
          return callback({ cancel: true });
        } catch (err) {
          return callback({ cancel: true });
        }
      });
      console.log('[main] renderer http/https requests will be blocked (whitelist applied).');
    } catch (err) {
      console.warn('[main] could not install webRequest block handler:', err);
    }
  } catch (err) {
    console.error('[main] initialization error', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  try {
    console.log('[main] registering IPC handlers');

    ipcMain.handle('create-note', async (_event, title: unknown) => {
      if (!isString(title)) throw new Error('Invalid title');
      const note = createNote(String(title), '');
      const filePath = await saveNoteContent(note.id, '');
      updateNoteFilePath(note.id, filePath);

      try {
        upsertNoteFts(note.id, note.title, '');
      } catch (err) {
        console.warn('[main] could not create FTS entry for new note', note.id, err);
      }

      const updatedNote = getNoteById(note.id);
      if (!updatedNote) {
        throw new Error(`Failed to retrieve note ${note.id} after creation`);
      }
      return updatedNote;
    });

    ipcMain.handle('save-note', async (_event, id: unknown, content: unknown) => {
      if (!isPositiveInteger(id) || !isString(content)) throw new Error('Invalid save-note args');
      const note = getNoteById(Number(id));
      if (note) {
        await saveNoteContent(Number(id), String(content));
        updateNote(Number(id)); // updates timestamps including lastEdited

        try {
          upsertNoteFts(Number(id), note.title, String(content));
        } catch (err) {
          console.error('[main] failed to update FTS index for note', id, err);
        }

        return getNoteById(Number(id)) ?? null;
      }
      return null;
    });

    ipcMain.handle('load-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) {
        return await loadNoteContent(note.filePath);
      }
      return '';
    });

    ipcMain.handle('get-all-notes', async () => {
      return getAllNotes();
    });

    ipcMain.handle('delete-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) {
        await deleteNoteFile(note.filePath);
        deleteNote(Number(id));

        try {
          removeNoteFts(Number(id));
        } catch (err) {
          console.warn('[main] failed to remove FTS entry for deleted note', id, err);
        }
      }
    });

    ipcMain.handle('update-note-title', async (_event, id: unknown, title: unknown) => {
      if (!isPositiveInteger(id) || !isString(title)) throw new Error('Invalid args');
      updateNoteTitle(Number(id), String(title));

      try {
        const note = getNoteById(Number(id));
        if (note) {
          const content = await loadNoteContent(note.filePath);
          upsertNoteFts(Number(id), String(title), content);
        }
      } catch (err) {
        console.warn('[main] failed to update FTS entry after title change', id, err);
      }
    });

    ipcMain.handle('get-notes-page', async (_event, page: unknown, perPage: unknown) => {
      if (!isPositiveInteger(page) || !isPositiveInteger(perPage)) throw new Error('Invalid pagination args');
      return getNotesPage(Number(page), Number(perPage));
    });

    // Tag operations
    ipcMain.handle('add-tag-to-note', async (_event, noteId: unknown, tagName: unknown, position: unknown) => {
      if (!isPositiveInteger(noteId) || !isNonEmptyString(tagName) || typeof position !== 'number') {
        throw new Error('Invalid args for add-tag-to-note');
      }
      return addTagToNote(Number(noteId), String(tagName), Number(position));
    });

    ipcMain.handle('remove-tag-from-note', async (_event, noteId: unknown, tagId: unknown) => {
      if (!isPositiveInteger(noteId) || !isPositiveInteger(tagId)) throw new Error('Invalid args');
      removeTagFromNote(Number(noteId), Number(tagId));
    });

    ipcMain.handle('reorder-note-tags', async (_event, noteId: unknown, tagIds: unknown) => {
      if (!isPositiveInteger(noteId) || !Array.isArray(tagIds)) throw new Error('Invalid args');
      reorderNoteTags(Number(noteId), tagIds as number[]);
    });

    ipcMain.handle('get-note-tags', async (_event, noteId: unknown) => {
      if (!isPositiveInteger(noteId)) throw new Error('Invalid args');
      return getNoteTags(Number(noteId));
    });

    ipcMain.handle('get-all-tags', async () => {
      return getAllTags();
    });

    ipcMain.handle('get-top-tags', async (_event, limit: unknown) => {
      if (!isPositiveInteger(limit)) throw new Error('Invalid args');
      return getTopTags(Number(limit));
    });

    // Search operations
    ipcMain.handle('search-notes', async (_event, query: unknown) => {
      if (!isString(query)) throw new Error('Invalid query');
      try {
        return await searchNotes(String(query));
      } catch (err) {
        console.error('[main] search-notes failed', err);
        return [] as SearchResult[];
      }
    });

    ipcMain.handle('search-notes-by-tag', async (_event, tagName: unknown) => {
      if (!isString(tagName)) throw new Error('Invalid tagName');
      return searchNotesByTag(String(tagName));
    });

    ipcMain.handle('get-notes-by-primary-tag', async () => {
      return getNotesByPrimaryTag();
    });

    ipcMain.handle('get-category-hierarchy', async () => {
      return getCategoryHierarchy();
    });

    ipcMain.handle('get-last-edited-note', async () => {
      const n = getLastEditedNote();
      return n ?? null;
    });

    // IPC: Request force save -> main notifies the focused renderer to run their force-save handlers
    ipcMain.handle('request-force-save', async () => {
      try {
        const focused = BrowserWindow.getFocusedWindow() ?? mainWindow;
        if (focused && focused.webContents) {
          // broadcast to that window
          focused.webContents.send('do-force-save');
          return { ok: true };
        }
        // no window focused; still ok
        return { ok: true };
      } catch (err) {
        console.warn('[main] request-force-save failed', err);
        return { ok: false };
      }
    });

    // Spellchecker languages mutation (already present)
    ipcMain.handle('set-spellchecker-languages', async (_event, langs: unknown) => {
      if (!isStringArray(langs)) throw new Error('Invalid langs array');
      try {
        await setDefaultSpellCheckerLanguages(langs as string[]);
        return { ok: true };
      } catch (err) {
        return { ok: false, error: String(err) };
      }
    });

    console.log('[main] IPC handlers registered');
  } catch (err) {
    console.error('[main] error registering IPC handlers', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  try {
    console.log('[main] creating window');
    createWindow();
    console.log('[main] window creation requested');
  } catch (err) {
    console.error('[main] createWindow threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
}).catch(err => {
  console.error('[main] whenReady threw', err && (err as any).stack ? (err as any).stack : err);
  throw err;
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    try {
      closeDatabase();
    } catch (err) {
      console.error('[main] closeDatabase error', err);
    }
    app.quit();
  }
});

app.on('before-quit', () => {
  try {
    closeDatabase();
  } catch (err) {
    console.error('[main] closeDatabase error', err);
  }
});
