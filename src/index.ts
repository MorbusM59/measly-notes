import { app, BrowserWindow, ipcMain, session, shell, Menu } from 'electron';
import {
  initDatabase, createNote, getAllNotes, updateNote, updateNoteTitle, deleteNote,
  getNoteById, closeDatabase, updateNoteFilePath, getNotesPage,
  addTagToNote, removeTagFromNote, reorderNoteTags, getNoteTags,
  getAllTags, getTopTags, searchNotesByTag, getNotesByPrimaryTag, getCategoryHierarchy, getLastEditedNote,
  upsertNoteFts, removeNoteFts, searchNotes, saveNoteUiState, getNoteUiState
} from './main/database';
import { initFileSystem, saveNoteContent, loadNoteContent, deleteNoteFile } from './main/fileSystem';
import { SearchResult } from './shared/types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Basic validators
function isString(v: unknown): v is string {
  return typeof v === 'string';
}
function isNonEmptyString(v: unknown): v is string {
  return isString(v) && v.trim().length > 0;
}
function isPositiveInteger(v: unknown): v is number {
  return typeof v === 'number' && Number.isInteger(v) && v >= 0;
}
function isStringArray(v: unknown): v is string[] {
  return Array.isArray(v) && v.every(i => typeof i === 'string');
}

// Global error handlers
process.on('uncaughtException', (err) => {
  console.error('[main] uncaughtException', err && err.stack ? err.stack : err);
});
process.on('unhandledRejection', (reason) => {
  console.error('[main] unhandledRejection', reason && (reason as any).stack ? (reason as any).stack : reason);
});

// Windows installer check
try {
  if (require('electron-squirrel-startup')) {
    app.quit();
  }
} catch (err) {
  console.warn('[main] squirrel check failed:', err);
}

app.disableHardwareAcceleration();

let mainWindow: BrowserWindow | null = null;

function getInternalHostnames(): Set<string> {
  const hosts = new Set<string>(['localhost', '127.0.0.1', '::1']);
  try {
    if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
      const u = new URL(MAIN_WINDOW_WEBPACK_ENTRY);
      if (u.hostname) hosts.add(u.hostname);
    }
  } catch (_) {}
  return hosts;
}

function shouldOpenExternally(urlStr: string, internalHosts: Set<string>): boolean {
  if (!urlStr) return false;
  try {
    const parsed = new URL(urlStr);
    const protocol = parsed.protocol.toLowerCase();
    if (protocol !== 'http:' && protocol !== 'https:') return false;
    if (internalHosts.has(parsed.hostname)) return false;
    return true;
  } catch {
    return false;
  }
}

const createWindow = (): void => {
  console.log('[main] createWindow() - start');
  try {
    mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      minWidth: 790,
      minHeight: 550,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        nodeIntegration: false,
        spellcheck: true,
      },
      show: false,
      autoHideMenuBar: true,
    });

    mainWindow.once('ready-to-show', () => {
      try { mainWindow?.show(); } catch (err) { console.error('[main] error showing window', err); }
    });

    const internalHosts = getInternalHostnames();

    if (app.isPackaged) {
      mainWindow.webContents.on('will-navigate', (event, url) => {
        event.preventDefault();
        if (shouldOpenExternally(url, internalHosts)) {
          try { shell.openExternal(url); console.log('[main] opened external URL from will-navigate:', url); }
          catch (err) { console.warn('[main] failed to open external URL from will-navigate:', url, err); }
        } else {
          console.log('[main] blocked internal navigation attempt to:', url);
        }
      });
    } else {
      // In dev, allow all internal navigation for smooth hot reloading
      mainWindow.webContents.on('will-navigate', (_event, url) => {
        // No action, allow navigation for fast refresh
      });
    }

    try {
      const wcAny = mainWindow.webContents as any;
      if (wcAny && typeof wcAny.setWindowOpenHandler === 'function') {
        wcAny.setWindowOpenHandler(({ url }: { url: string }) => {
          if (shouldOpenExternally(url, internalHosts)) {
            try { shell.openExternal(url); console.log('[main] opened external URL from setWindowOpenHandler:', url); }
            catch (err) { console.warn('[main] failed to open external URL from setWindowOpenHandler:', url, err); }
          } else {
            console.log('[main] denied window.open to internal URL:', url);
          }
          return { action: 'deny' };
        });
      } else if (wcAny && typeof wcAny.on === 'function') {
        wcAny.on('new-window', (event: any, url: any) => {
          try { event.preventDefault(); } catch (_) {}
          const urlStr = String(url || '');
          if (shouldOpenExternally(urlStr, internalHosts)) {
            try { shell.openExternal(urlStr); console.log('[main] opened external URL from new-window fallback:', urlStr); }
            catch (err) { console.warn('[main] failed to open external URL from new-window fallback:', urlStr, err); }
          } else {
            console.log('[main] denied new-window to internal URL:', urlStr);
          }
        });
      }
    } catch (err) {
      console.warn('[main] window-open handlers setup failed:', err);
    }

    mainWindow.on('closed', () => { mainWindow = null; });

    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch(err => {
      console.error('[main] loadURL failed', err && err.stack ? err.stack : err);
    });

    if (process.env.NODE_ENV === 'development') {
      mainWindow.webContents.openDevTools();
    }
  } catch (err) {
    console.error('[main] createWindow threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }
};

async function setDefaultSpellCheckerLanguages(langs: string[]) {
  try {
    await session.defaultSession.setSpellCheckerLanguages(langs);
    if ((session.defaultSession as any).setSpellCheckerEnabled) {
      try { (session.defaultSession as any).setSpellCheckerEnabled(true); } catch (err) { console.warn('[main] could not setSpellCheckerEnabled:', err); }
    }
    console.log('[main] spellchecker languages set to:', langs);
  } catch (err) {
    console.warn('[main] failed to set spellchecker languages:', err);
  }
}

// Keep an in-memory map of outstanding force-save requests so we can match replies.
const pendingForceSaves = new Map<string, { webContentsId: number; resolve: (ok: boolean) => void; timer: NodeJS.Timeout }>();

// Handle renderer -> main completion messages
ipcMain.on('force-save-complete', (event, requestId?: string) => {
  if (!requestId) return;
  const pending = pendingForceSaves.get(requestId);
  if (!pending) return;
  // ensure sender is same window that requested the save
  if (event.sender.id !== pending.webContentsId) {
    // ignore mismatched sender
    return;
  }
  clearTimeout(pending.timer);
  pending.resolve(true);
  pendingForceSaves.delete(requestId);
});

app.whenReady().then(async () => {
  console.log('[main] app.whenReady started');
  try {
    await initDatabase();
    await initFileSystem();
    await setDefaultSpellCheckerLanguages(['en-US', 'de-DE']);

    // webRequest whitelist/block: Only enable in production
    if (app.isPackaged) {
      const whitelistHostnames = getInternalHostnames();
      try {
        if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
          const mainHost = new URL(MAIN_WINDOW_WEBPACK_ENTRY).hostname;
          whitelistHostnames.add(mainHost);
        }
      } catch (_) {}

      // Block http(s) and ws(s) in production only
      session.defaultSession.webRequest.onBeforeRequest(
        { urls: ['http://*/*', 'https://*/*', 'ws://*/*', 'wss://*/*'] },
        (details: any, callback: (response: { cancel: boolean }) => void) => {
          try {
            const urlStr: string = details.url || '';
            if (urlStr.startsWith('file:')) return callback({ cancel: false });
            let hostname = '';
            try { hostname = new URL(urlStr).hostname; } catch { return callback({ cancel: true }); }
            if (whitelistHostnames.has(hostname)) return callback({ cancel: false });
            return callback({ cancel: true });
          } catch (err) { return callback({ cancel: true }); }
        }
      );
      console.log('[main] renderer http/https/ws requests will be blocked (whitelist applied).');
    } else {
      // Allow all requests in development for live reload/hot CSS 
      console.log('[main] DEV MODE: All renderer http/https/ws requests allowed for live reload/hot CSS!');
    }
  } catch (err) {
    console.error('[main] initialization error', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  // Register IPC handlers (validate inputs) - same set as before (create-note, save-note, etc.)
  try {
    ipcMain.handle('create-note', async (_event, title: unknown) => {
      if (!isString(title)) throw new Error('Invalid title');
      const note = createNote(String(title), '');
      const filePath = await saveNoteContent(note.id, '');
      updateNoteFilePath(note.id, filePath);
      try { upsertNoteFts(note.id, note.title, ''); } catch (err) { console.warn('[main] could not create FTS entry for new note', note.id, err); }
      const updatedNote = getNoteById(note.id);
      if (!updatedNote) throw new Error(`Failed to retrieve note ${note.id} after creation`);
      return updatedNote;
    });

    ipcMain.handle('save-note', async (_event, id: unknown, content: unknown) => {
      if (!isPositiveInteger(id) || !isString(content)) throw new Error('Invalid save-note args');
      const note = getNoteById(Number(id));
      if (note) {
        await saveNoteContent(Number(id), String(content));
        updateNote(Number(id));
        try { upsertNoteFts(Number(id), note.title, String(content)); } catch (err) { console.error('[main] failed to update FTS index for note', id, err); }
        return getNoteById(Number(id)) ?? null;
      }
      return null;
    });

    ipcMain.handle('load-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) return await loadNoteContent(note.filePath);
      return '';
    });

    ipcMain.handle('get-all-notes', async () => getAllNotes());
    ipcMain.handle('delete-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) {
        await deleteNoteFile(note.filePath);
        deleteNote(Number(id));
        try { removeNoteFts(Number(id)); } catch (err) { console.warn('[main] failed to remove FTS entry for deleted note', id, err); }
      }
    });

    ipcMain.handle('update-note-title', async (_event, id: unknown, title: unknown) => {
      if (!isPositiveInteger(id) || !isString(title)) throw new Error('Invalid args');
      updateNoteTitle(Number(id), String(title));
      try {
        const note = getNoteById(Number(id));
        if (note) {
          const content = await loadNoteContent(note.filePath);
          upsertNoteFts(Number(id), String(title), content);
        }
      } catch (err) { console.warn('[main] failed to update FTS entry after title change', id, err); }
    });

    ipcMain.handle('get-notes-page', async (_event, page: unknown, perPage: unknown) => {
      if (!isPositiveInteger(page) || !isPositiveInteger(perPage)) throw new Error('Invalid pagination args');
      return getNotesPage(Number(page), Number(perPage));
    });

    ipcMain.handle('add-tag-to-note', async (_event, noteId: unknown, tagName: unknown, position: unknown) => {
      if (!isPositiveInteger(noteId) || !isNonEmptyString(tagName) || typeof position !== 'number') throw new Error('Invalid args for add-tag-to-note');
      return addTagToNote(Number(noteId), String(tagName), Number(position));
    });

    ipcMain.handle('remove-tag-from-note', async (_event, noteId: unknown, tagId: unknown) => {
      if (!isPositiveInteger(noteId) || !isPositiveInteger(tagId)) throw new Error('Invalid args');
      removeTagFromNote(Number(noteId), Number(tagId));
    });

    ipcMain.handle('reorder-note-tags', async (_event, noteId: unknown, tagIds: unknown) => {
      if (!isPositiveInteger(noteId) || !Array.isArray(tagIds)) throw new Error('Invalid args');
      reorderNoteTags(Number(noteId), tagIds as number[]);
    });

    ipcMain.handle('get-note-tags', async (_event, noteId: unknown) => {
      if (!isPositiveInteger(noteId)) throw new Error('Invalid args');
      return getNoteTags(Number(noteId));
    });

    ipcMain.handle('get-all-tags', async () => getAllTags());
    ipcMain.handle('get-top-tags', async (_event, limit: unknown) => {
      if (!isPositiveInteger(limit)) throw new Error('Invalid args');
      return getTopTags(Number(limit));
    });

    ipcMain.handle('search-notes', async (_event, query: unknown) => {
      if (!isString(query)) throw new Error('Invalid query');
      try { return await searchNotes(String(query)); } catch (err) { console.error('[main] search-notes failed', err); return [] as SearchResult[]; }
    });

    ipcMain.handle('search-notes-by-tag', async (_event, tagName: unknown) => {
      if (!isString(tagName)) throw new Error('Invalid tagName');
      return searchNotesByTag(String(tagName));
    });

    ipcMain.handle('get-notes-by-primary-tag', async () => getNotesByPrimaryTag());
    ipcMain.handle('get-category-hierarchy', async () => getCategoryHierarchy());
    ipcMain.handle('get-last-edited-note', async () => getLastEditedNote() ?? null);

    ipcMain.handle('save-note-ui-state', async (_event, noteId: unknown, state: unknown) => {
      if (!isPositiveInteger(noteId) || typeof state !== 'object' || state === null) throw new Error('Invalid args');
      const s = state as { progressPreview?: number | null; progressEdit?: number | null; cursorPos?: number | null; scrollTop?: number | null };
      try { saveNoteUiState(Number(noteId), s); } catch (err) { console.warn('[main] saveNoteUiState failed', err); }
    });

    ipcMain.handle('get-note-ui-state', async (_event, noteId: unknown) => {
      if (!isPositiveInteger(noteId)) throw new Error('Invalid args');
      try { return getNoteUiState(Number(noteId)); } catch (err) { console.warn('[main] getNoteUiState failed', err); return { progressPreview: null, progressEdit: null, cursorPos: null, scrollTop: null }; }
    });

    // request-force-save: send do-force-save with requestId to focused window and wait for completion or timeout
    ipcMain.handle('request-force-save', async () => {
      try {
        const focused = BrowserWindow.getFocusedWindow() ?? mainWindow;
        if (!focused || !focused.webContents) {
          return { ok: true }; // nothing to do
        }

        const requestId = `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const webContentsId = focused.webContents.id;

        // send request
        focused.webContents.send('do-force-save', requestId);

        // wait for completion with timeout
        const p = new Promise<{ ok: boolean }>((resolve) => {
          const timer = setTimeout(() => {
            // timeout - resolve false but still remove from map
            pendingForceSaves.delete(requestId);
            resolve({ ok: false });
          }, 2000);

          pendingForceSaves.set(requestId, {
            webContentsId,
            resolve: (ok: boolean) => resolve({ ok }),
            timer,
          });
        });

        return await p;
      } catch (err) {
        console.warn('[main] request-force-save failed', err);
        return { ok: false };
      }
    });

    ipcMain.handle('set-spellchecker-languages', async (_event, langs: unknown) => {
      if (!isStringArray(langs)) throw new Error('Invalid langs array');
      try {
        await setDefaultSpellCheckerLanguages(langs as string[]);
        return { ok: true };
      } catch (err) {
        return { ok: false, error: String(err) };
      }
    });

    console.log('[main] IPC handlers registered');
  } catch (err) {
    console.error('[main] error registering IPC handlers', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
}).catch(err => {
  console.error('[main] whenReady threw', err && (err as any).stack ? (err as any).stack : err);
  throw err;
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    try { closeDatabase(); } catch (err) { console.error('[main] closeDatabase error', err); }
    app.quit();
  }
});

app.on('before-quit', () => {
  try { closeDatabase(); } catch (err) { console.error('[main] closeDatabase error', err); }
});
