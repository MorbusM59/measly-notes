import { app, BrowserWindow, ipcMain, session, shell } from 'electron';
import {
  initDatabase, createNote, getAllNotes, updateNote, updateNoteTitle, deleteNote,
  getNoteById, closeDatabase, updateNoteFilePath, getNotesPage,
  addTagToNote, removeTagFromNote, reorderNoteTags, getNoteTags,
  getAllTags, getTopTags, searchNotesByTag, getNotesByPrimaryTag, getCategoryHierarchy, getLastEditedNote,
  upsertNoteFts, removeNoteFts, searchNotes
} from './main/database';
import { initFileSystem, saveNoteContent, loadNoteContent, deleteNoteFile } from './main/fileSystem';
import { SearchResult } from './shared/types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Global error handlers to make crashes visible in the terminal
process.on('uncaughtException', (err) => {
  console.error('[main] uncaughtException', err && err.stack ? err.stack : err);
});
process.on('unhandledRejection', (reason) => {
  console.error('[main] unhandledRejection', reason && (reason as any).stack ? (reason as any).stack : reason);
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
try {
  if (require('electron-squirrel-startup')) {
    app.quit();
  }
} catch (err) {
  // in some environments require may behave differently; log and continue
  console.warn('[main] squirrel check failed:', err);
}

// Disable GPU hardware acceleration to prevent GPU process crashes on Windows.
app.disableHardwareAcceleration();

let mainWindow: BrowserWindow | null = null;

const createWindow = (): void => {
  console.log('[main] createWindow() - start');
  try {
    mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        nodeIntegration: false,
        // enable Chromium spellchecker in the renderer
        spellcheck: true,
      },
      show: false, // show when ready-to-show
    });

    mainWindow.once('ready-to-show', () => {
      console.log('[main] mainWindow ready-to-show -> showing');
      try {
        mainWindow?.show();
      } catch (err) {
        console.error('[main] error showing window', err);
      }
    });

    // Prevent navigation and always open external links in the OS default browser.
    // This ensures the app never navigates away to remote content.
    mainWindow.webContents.on('will-navigate', (event, url) => {
      if (url) {
        event.preventDefault();
        try {
          shell.openExternal(url);
        } catch (err) {
          console.warn('[main] failed to open external URL from will-navigate:', url, err);
        }
      }
    });

    // Prefer setWindowOpenHandler where available
    try {
      // cast to any to avoid strict signature mismatch across Electron versions
      const wcAny = mainWindow.webContents as any;
      if (wcAny.setWindowOpenHandler) {
        wcAny.setWindowOpenHandler(({ url }: { url: string }) => {
          try {
            shell.openExternal(url);
          } catch (err) {
            console.warn('[main] failed to open external URL from setWindowOpenHandler:', url, err);
          }
          return { action: 'deny' };
        });
      }
      // Fallback for older Electron versions that emit 'new-window'
      wcAny.on && wcAny.on('new-window', (event: any, url: any) => {
        try {
          event.preventDefault();
        } catch (_) {}
        try {
          shell.openExternal(String(url));
        } catch (err) {
          console.warn('[main] failed to open external URL from new-window fallback:', url, err);
        }
      });
    } catch (err) {
      console.warn('[main] window-open handlers setup failed:', err);
    }

    mainWindow.on('closed', () => {
      console.log('[main] mainWindow closed');
      mainWindow = null;
    });

    console.log('[main] loading URL:', MAIN_WINDOW_WEBPACK_ENTRY);
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch(err => {
      console.error('[main] loadURL failed', err && err.stack ? err.stack : err);
    });

    if (process.env.NODE_ENV === 'development') {
      console.log('[main] opening devtools (development mode)');
      mainWindow.webContents.openDevTools();
    }

    console.log('[main] createWindow() - done');
  } catch (err) {
    console.error('[main] createWindow() threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }
};

// Helper: set default spellchecker languages (multiple)
async function setDefaultSpellCheckerLanguages(langs: string[]) {
  try {
    // setSpellCheckerLanguages is available on session in recent Electron/Chromium builds
    // This call may be a no-op on some platforms if dictionaries aren't available.
    await session.defaultSession.setSpellCheckerLanguages(langs);

    // Try to enable the spellchecker if available on this Electron version/platform.
    // Some versions/platforms manage this differently, so ignore failures.
    if ((session.defaultSession as any).setSpellCheckerEnabled) {
      try {
        (session.defaultSession as any).setSpellCheckerEnabled(true);
      } catch (err) {
        // Non-fatal: some platforms manage spellchecker state differently
        console.warn('[main] could not setSpellCheckerEnabled:', err);
      }
    }

    console.log('[main] spellchecker languages set to:', langs);
  } catch (err) {
    console.warn('[main] failed to set spellchecker languages:', err);
  }
}

// Initialize app
app.whenReady().then(async () => {
  console.log('[main] app.whenReady started');
  try {
    await initDatabase();
    console.log('[main] initDatabase OK');
    await initFileSystem();
    console.log('[main] initFileSystem OK');

    // Ensure English and German spellchecking are set by default on every machine.
    // Note: on Linux you may need Hunspell dictionaries available to Chromium for this to work.
    await setDefaultSpellCheckerLanguages(['en-US', 'de-DE']);

    // Block outgoing http(s) requests initiated by the renderer, but whitelist local/dev hosts
    try {
      const whitelistHostnames = new Set(['localhost', '127.0.0.1', '::1']);
      // If MAIN_WINDOW_WEBPACK_ENTRY is a http(s) URL (dev), whitelist its host as well
      try {
        if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
          const mainHost = new URL(MAIN_WINDOW_WEBPACK_ENTRY).hostname;
          whitelistHostnames.add(mainHost);
        }
      } catch (_) {}

      session.defaultSession.webRequest.onBeforeRequest({ urls: ['http://*/*', 'https://*/*'] }, (details: any, callback: (response: { cancel: boolean }) => void) => {
        try {
          const urlStr: string = details.url || '';
          // Allow file protocol
          if (urlStr.startsWith('file:')) {
            return callback({ cancel: false });
          }
          // Safely parse hostname and allow localhost/dev server traffic
          let hostname = '';
          try {
            hostname = new URL(urlStr).hostname;
          } catch (err) {
            // If parsing fails, be conservative and block
            return callback({ cancel: true });
          }
          if (whitelistHostnames.has(hostname)) {
            return callback({ cancel: false });
          }
          // Otherwise cancel any external HTTP/S request originating from renderer
          return callback({ cancel: true });
        } catch (err) {
          // On any unexpected error, cancel to be safe
          return callback({ cancel: true });
        }
      });
      console.log('[main] renderer http/https requests will be blocked (whitelist applied).');
    } catch (err) {
      console.warn('[main] could not install webRequest block handler:', err);
    }
  } catch (err) {
    console.error('[main] initialization error', err && (err as any).stack ? (err as any).stack : err);
    // Rethrow so the process fails visibly
    throw err;
  }

  try {
    console.log('[main] registering IPC handlers');

    ipcMain.handle('create-note', async (_, title: string) => {
      const note = createNote(title, '');
      const filePath = await saveNoteContent(note.id, '');
      updateNoteFilePath(note.id, filePath);

      // Ensure FTS entry exists for the new note (empty content initially)
      try {
        upsertNoteFts(note.id, note.title, '');
      } catch (err) {
        console.warn('[main] could not create FTS entry for new note', note.id, err);
      }

      const updatedNote = getNoteById(note.id);
      if (!updatedNote) {
        throw new Error(`Failed to retrieve note ${note.id} after creation`);
      }
      return updatedNote;
    });

    ipcMain.handle('save-note', async (_, id: number, content: string) => {
      const note = getNoteById(id);
      if (note) {
        await saveNoteContent(id, content);
        updateNote(id); // updates timestamps including lastEdited

        // Update FTS index so searches will include the new content
        try {
          upsertNoteFts(id, note.title, content);
        } catch (err) {
          console.error('[main] failed to update FTS index for note', id, err);
        }

        return getNoteById(id) ?? null;
      }
      return null;
    });

    ipcMain.handle('load-note', async (_, id: number) => {
      const note = getNoteById(id);
      if (note) {
        return await loadNoteContent(note.filePath);
      }
      return '';
    });

    ipcMain.handle('get-all-notes', async () => {
      return getAllNotes();
    });

    ipcMain.handle('delete-note', async (_, id: number) => {
      const note = getNoteById(id);
      if (note) {
        await deleteNoteFile(note.filePath);
        deleteNote(id);

        // Remove FTS entry if present
        try {
          removeNoteFts(id);
        } catch (err) {
          console.warn('[main] failed to remove FTS entry for deleted note', id, err);
        }
      }
    });

    ipcMain.handle('update-note-title', async (_, id: number, title: string) => {
      updateNoteTitle(id, title);

      // keep FTS title in sync; load content to preserve FTS content column
      try {
        const note = getNoteById(id);
        if (note) {
          const content = await loadNoteContent(note.filePath);
          upsertNoteFts(id, title, content);
        }
      } catch (err) {
        console.warn('[main] failed to update FTS entry after title change', id, err);
      }
    });

    ipcMain.handle('get-notes-page', async (_, page: number, perPage: number) => {
      return getNotesPage(page, perPage);
    });

    // Tag operations
    ipcMain.handle('add-tag-to-note', async (_, noteId: number, tagName: string, position: number) => {
      return addTagToNote(noteId, tagName, position);
    });

    ipcMain.handle('remove-tag-from-note', async (_, noteId: number, tagId: number) => {
      removeTagFromNote(noteId, tagId);
    });

    ipcMain.handle('reorder-note-tags', async (_, noteId: number, tagIds: number[]) => {
      reorderNoteTags(noteId, tagIds);
    });

    ipcMain.handle('get-note-tags', async (_, noteId: number) => {
      return getNoteTags(noteId);
    });

    ipcMain.handle('get-all-tags', async () => {
      return getAllTags();
    });

    ipcMain.handle('get-top-tags', async (_, limit: number) => {
      return getTopTags(limit);
    });

    // Search operations - delegate to FTS-backed search
    ipcMain.handle('search-notes', async (_, query: string) => {
      try {
        return await searchNotes(query);
      } catch (err) {
        console.error('[main] search-notes failed', err);
        // Fallback: return empty results on error
        return [] as SearchResult[];
      }
    });

    ipcMain.handle('search-notes-by-tag', async (_, tagName: string) => {
      return searchNotesByTag(tagName);
    });

    ipcMain.handle('get-notes-by-primary-tag', async () => {
      return getNotesByPrimaryTag();
    });

    ipcMain.handle('get-category-hierarchy', async () => {
      return getCategoryHierarchy();
    });

    ipcMain.handle('get-last-edited-note', async () => {
      const n = getLastEditedNote();
      return n ?? null;
    });

    // Allow renderer to change spellchecker languages at runtime (optional)
    ipcMain.handle('set-spellchecker-languages', async (_event, langs: string[]) => {
      try {
        await setDefaultSpellCheckerLanguages(langs);
        return { ok: true };
      } catch (err) {
        return { ok: false, error: String(err) };
      }
    });

    console.log('[main] IPC handlers registered');
  } catch (err) {
    console.error('[main] error registering IPC handlers', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  try {
    console.log('[main] creating window');
    createWindow();
    console.log('[main] window creation requested');
  } catch (err) {
    console.error('[main] createWindow threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
}).catch(err => {
  console.error('[main] whenReady threw', err && (err as any).stack ? (err as any).stack : err);
  // rethrow to make the process exit in dev so you see the error
  throw err;
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    try {
      closeDatabase();
    } catch (err) {
      console.error('[main] closeDatabase error', err);
    }
    app.quit();
  }
});

app.on('before-quit', () => {
  try {
    closeDatabase();
  } catch (err) {
    console.error('[main] closeDatabase error', err);
  }
});
