import { app, BrowserWindow, ipcMain } from 'electron';
import { 
  initDatabase, createNote, getAllNotes, updateNote, updateNoteTitle, deleteNote, 
  getNoteById, closeDatabase, updateNoteFilePath, getNotesPage,
  addTagToNote, removeTagFromNote, reorderNoteTags, getNoteTags, 
  getAllTags, getTopTags, searchNotesByTag, getNotesByPrimaryTag
} from './main/database';
import { initFileSystem, saveNoteContent, loadNoteContent, deleteNoteFile } from './main/fileSystem';
import { SearchResult } from './shared/types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development.
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

// Initialize app
app.whenReady().then(async () => {
  await initDatabase();
  await initFileSystem();
  
  // Register IPC handlers
  ipcMain.handle('create-note', async (_, title: string) => {
    const note = createNote(title, '');
    const filePath = await saveNoteContent(note.id, '');
    updateNoteFilePath(note.id, filePath);
    const updatedNote = getNoteById(note.id);
    if (!updatedNote) {
      throw new Error(`Failed to retrieve note ${note.id} after creation`);
    }
    return updatedNote;
  });

  ipcMain.handle('save-note', async (_, id: number, content: string) => {
    const note = getNoteById(id);
    if (note) {
      await saveNoteContent(id, content);
      updateNote(id);
    }
  });

  ipcMain.handle('load-note', async (_, id: number) => {
    const note = getNoteById(id);
    if (note) {
      return await loadNoteContent(note.filePath);
    }
    return '';
  });

  ipcMain.handle('get-all-notes', async () => {
    return getAllNotes();
  });

  ipcMain.handle('delete-note', async (_, id: number) => {
    const note = getNoteById(id);
    if (note) {
      await deleteNoteFile(note.filePath);
      deleteNote(id);
    }
  });

  ipcMain.handle('update-note-title', async (_, id: number, title: string) => {
    updateNoteTitle(id, title);
  });

  ipcMain.handle('get-notes-page', async (_, page: number, perPage: number) => {
    return getNotesPage(page, perPage);
  });

  // Tag operations
  ipcMain.handle('add-tag-to-note', async (_, noteId: number, tagName: string, position: number) => {
    return addTagToNote(noteId, tagName, position);
  });

  ipcMain.handle('remove-tag-from-note', async (_, noteId: number, tagId: number) => {
    removeTagFromNote(noteId, tagId);
  });

  ipcMain.handle('reorder-note-tags', async (_, noteId: number, tagIds: number[]) => {
    reorderNoteTags(noteId, tagIds);
  });

  ipcMain.handle('get-note-tags', async (_, noteId: number) => {
    return getNoteTags(noteId);
  });

  ipcMain.handle('get-all-tags', async () => {
    return getAllTags();
  });

  ipcMain.handle('get-top-tags', async (_, limit: number) => {
    return getTopTags(limit);
  });

  // Search operations
  ipcMain.handle('search-notes', async (_, query: string) => {
    const allNotes = getAllNotes();
    const results: SearchResult[] = [];
    
    for (const note of allNotes) {
      const matchInTitle = note.title.toLowerCase().includes(query.toLowerCase());
      
      // Load note content to search
      const content = await loadNoteContent(note.filePath);
      const matchInContent = content.toLowerCase().includes(query.toLowerCase());
      
      if (matchInTitle || matchInContent) {
        results.push({
          note,
          matchType: matchInTitle ? 'title' : 'content',
          snippet: matchInContent ? extractSnippet(content, query) : undefined
        });
      }
    }
    
    return results;
  });

  function extractSnippet(content: string, query: string, radius = 50): string {
    const lowerContent = content.toLowerCase();
    const lowerQuery = query.toLowerCase();
    const index = lowerContent.indexOf(lowerQuery);
    
    if (index === -1) return '';
    
    const start = Math.max(0, index - radius);
    const end = Math.min(content.length, index + query.length + radius);
    
    let snippet = content.substring(start, end);
    if (start > 0) snippet = '...' + snippet;
    if (end < content.length) snippet = snippet + '...';
    
    return snippet;
  }

  ipcMain.handle('search-notes-by-tag', async (_, tagName: string) => {
    return searchNotesByTag(tagName);
  });

  ipcMain.handle('get-notes-by-primary-tag', async () => {
    return getNotesByPrimaryTag();
  });

  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    closeDatabase();
    app.quit();
  }
});

app.on('before-quit', () => {
  closeDatabase();
});
