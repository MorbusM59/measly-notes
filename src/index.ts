import { app, BrowserWindow, ipcMain, session, shell, Menu, dialog } from 'electron';
import * as path from 'path';
import * as fs from 'fs';
import { getDataDir } from './main/paths';
import {
  initDatabase, createNote, getAllNotes, updateNote, updateNoteTitle, deleteNote,
  getNoteById, closeDatabase, updateNoteFilePath, getNotesPage,
  addTagToNote, removeTagFromNote, reorderNoteTags, getNoteTags,
  getAllTags, getTopTags, searchNotesByTag, getNotesByPrimaryTag, getCategoryHierarchy, getLastEditedNote,
  upsertNoteFts, removeNoteFts, searchNotes, saveNoteUiState, getNoteUiState, getHierarchyForTag, getNotesInTrash,
  generateUniqueFileToken, setNoteFileToken, getNoteByToken, reconcileNotesWithFs, updateNoteCreatedAt, updateNoteLastEdited, renameTag } from './main/database';

import { initFileSystem, saveNoteContent, loadNoteContent, deleteNoteFile, copyFileToNotes } from './main/fileSystem';
import { SearchResult } from './shared/types';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Basic validators
function isString(v: unknown): v is string {
  return typeof v === 'string';
}
function isNonEmptyString(v: unknown): v is string {
  return isString(v) && v.trim().length > 0;
}
function isPositiveInteger(v: unknown): v is number {
  return typeof v === 'number' && Number.isInteger(v) && v >= 0;
}
function isStringArray(v: unknown): v is string[] {
  return Array.isArray(v) && v.every(i => typeof i === 'string');
}

// Global error handlers
process.on('uncaughtException', (err) => {
  console.error('[main] uncaughtException', err && err.stack ? err.stack : err);
});
process.on('unhandledRejection', (reason) => {
  console.error('[main] unhandledRejection', reason && (reason as any).stack ? (reason as any).stack : reason);
});

// Windows installer check
try {
  if (require('electron-squirrel-startup')) {
    app.quit();
  }
} catch (err) {
  console.warn('[main] squirrel check failed:', err);
}

app.disableHardwareAcceleration();

let mainWindow: BrowserWindow | null = null;

function getInternalHostnames(): Set<string> {
  const hosts = new Set<string>(['localhost', '127.0.0.1', '::1']);
  try {
    if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
      const u = new URL(MAIN_WINDOW_WEBPACK_ENTRY);
      if (u.hostname) hosts.add(u.hostname);
    }
  } catch (err) { console.warn('[main] getInternalHostnames parse failed', err); }
  return hosts;
}

function shouldOpenExternally(urlStr: string, internalHosts: Set<string>): boolean {
  if (!urlStr) return false;
  try {
    const parsed = new URL(urlStr);
    const protocol = parsed.protocol.toLowerCase();
    if (protocol !== 'http:' && protocol !== 'https:') return false;
    if (internalHosts.has(parsed.hostname)) return false;
    return true;
  } catch {
    return false;
  }
}

const createWindow = (): void => {
  console.log('[main] createWindow() - start');
  try {
    // Attempt to restore previous window state (bounds + maximized)
    const stateFile = path.join(getDataDir(), 'window-state.json');
    let restoredState: { x?: number; y?: number; width?: number; height?: number; isMaximized?: boolean } = {};
    try {
      if (fs.existsSync(stateFile)) {
        const raw = fs.readFileSync(stateFile, 'utf8');
        restoredState = JSON.parse(raw || '{}');
      }
    } catch (err) {
      console.warn('[main] failed to read window state:', err);
      restoredState = {};
    }
    // pick best dev icon per-platform (Windows prefers .ico for taskbar)
    const devIconFile = process.platform === 'win32' ? path.join(__dirname, '..', 'assets', 'icon.ico') : path.join(__dirname, '..', 'assets', 'icon.png');
    try { console.log('[main] using dev icon:', devIconFile, 'exists=', fs.existsSync(devIconFile)); } catch (err) { console.warn('[main] dev icon check failed', err); }

    const bwOpts: any = {
      width: restoredState.width ?? 1200,
      height: restoredState.height ?? 800,
      minWidth: 790,
      minHeight: 550,
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        contextIsolation: true,
        nodeIntegration: false,
        spellcheck: true,
      },
      // Use platform-specific icon during development.
      icon: devIconFile,
      show: false,
      autoHideMenuBar: true,
    };
    if (typeof restoredState.x === 'number' && typeof restoredState.y === 'number') {
      bwOpts.x = restoredState.x;
      bwOpts.y = restoredState.y;
    }

    mainWindow = new BrowserWindow(bwOpts);

    mainWindow.once('ready-to-show', () => {
      try { mainWindow?.show(); } catch (err) { console.error('[main] error showing window', err); }
      try {
        if (restoredState.isMaximized && mainWindow && !mainWindow.isDestroyed()) {
          try { mainWindow.maximize(); } catch (err) { console.warn('[main] failed to maximize on restore', err); }
        }
      } catch (err) { console.warn('[main] ready-to-show handler failed', err); }
    });

    const internalHosts = getInternalHostnames();

    if (app.isPackaged) {
      mainWindow.webContents.on('will-navigate', (event, url) => {
        event.preventDefault();
        if (shouldOpenExternally(url, internalHosts)) {
          try { shell.openExternal(url); console.log('[main] opened external URL from will-navigate:', url); }
          catch (err) { console.warn('[main] failed to open external URL from will-navigate:', url, err); }
        } else {
          console.log('[main] blocked internal navigation attempt to:', url);
        }
      });
    } else {
      // In dev, allow all internal navigation for smooth hot reloading
      mainWindow.webContents.on('will-navigate', (_event, url) => {
        // No action, allow navigation for fast refresh
      });
    }

    try {
      const wcAny = mainWindow.webContents as any;
      if (wcAny && typeof wcAny.setWindowOpenHandler === 'function') {
        wcAny.setWindowOpenHandler(({ url }: { url: string }) => {
          if (shouldOpenExternally(url, internalHosts)) {
            try { shell.openExternal(url); console.log('[main] opened external URL from setWindowOpenHandler:', url); }
            catch (err) { console.warn('[main] failed to open external URL from setWindowOpenHandler:', url, err); }
          } else {
            console.log('[main] denied window.open to internal URL:', url);
          }
          return { action: 'deny' };
        });
      } else if (wcAny && typeof wcAny.on === 'function') {
        wcAny.on('new-window', (event: any, url: any) => {
          try { event.preventDefault(); } catch (err) { console.warn('[main] event.preventDefault failed', err); }
          const urlStr = String(url || '');
          if (shouldOpenExternally(urlStr, internalHosts)) {
            try { shell.openExternal(urlStr); console.log('[main] opened external URL from new-window fallback:', urlStr); }
            catch (err) { console.warn('[main] failed to open external URL from new-window fallback:', urlStr, err); }
          } else {
            console.log('[main] denied new-window to internal URL:', urlStr);
          }
        });
      }
    } catch (err) {
      console.warn('[main] window-open handlers setup failed:', err);
    }

    mainWindow.on('closed', () => { mainWindow = null; });

    // Persist window bounds and maximized state on close
    try {
      const stateFilePath = path.join(getDataDir(), 'window-state.json');
      mainWindow.on('close', () => {
        try {
          if (!mainWindow) return;
          const isMax = mainWindow.isMaximized();
          // Prefer to store the "normal" bounds if maximized so we can restore properly
          let bounds = mainWindow.getBounds();
          try {
            // getNormalBounds exists on modern Electron; fallback to getBounds
            if (isMax && (mainWindow as any) && typeof (mainWindow as any).getNormalBounds === 'function') bounds = (mainWindow as any).getNormalBounds();
          } catch (err) { console.warn('[main] failed to get normal bounds', err); }
          const out = {
            x: bounds.x,
            y: bounds.y,
            width: bounds.width,
            height: bounds.height,
            isMaximized: isMax,
          };
          try {
            fs.mkdirSync(getDataDir(), { recursive: true });
          } catch (err) { console.warn('[main] failed to create data dir', err); }
          try { fs.writeFileSync(stateFilePath, JSON.stringify(out), 'utf8'); } catch (err) { console.warn('[main] failed to write window state', err); }
        } catch (err) {
          console.warn('[main] error while saving window state', err);
        }
      });
    } catch (err) {
      console.warn('[main] failed to register window state saver', err);
    }

    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY).catch(async (err) => {
      console.error('[main] loadURL failed', err && err.stack ? err.stack : err);
      try {
        // Dev server port mismatch can happen; try a common alternative (9000) if the entry references 3000
        if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.includes(':3000')) {
          const alt = MAIN_WINDOW_WEBPACK_ENTRY.replace(':3000', ':9000');
          console.log('[main] attempting fallback dev URL:', alt);
          try {
            await mainWindow?.loadURL(alt);
            console.log('[main] fallback dev URL loaded successfully');
            return;
          } catch (err2) {
            console.warn('[main] fallback dev URL failed', err2);
          }
        }
      } catch (e) {
        console.warn('[main] error in loadURL fallback', e);
      }
    });

    if (process.env.NODE_ENV === 'development') {
      mainWindow.webContents.openDevTools();
    }
  } catch (err) {
    console.error('[main] createWindow threw', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }
};

async function setDefaultSpellCheckerLanguages(langs: string[]) {
  try {
    await session.defaultSession.setSpellCheckerLanguages(langs);
    if ((session.defaultSession as any).setSpellCheckerEnabled) {
      try { (session.defaultSession as any).setSpellCheckerEnabled(true); } catch (err) { console.warn('[main] could not setSpellCheckerEnabled:', err); }
    }
    console.log('[main] spellchecker languages set to:', langs);
  } catch (err) {
    console.warn('[main] failed to set spellchecker languages:', err);
  }
}

// Keep an in-memory map of outstanding force-save requests so we can match replies.
const pendingForceSaves = new Map<string, { webContentsId: number; resolve: (ok: boolean) => void; timer: NodeJS.Timeout }>();

// Handle renderer -> main completion messages
ipcMain.on('force-save-complete', (event, requestId?: string) => {
  if (!requestId) return;
  const pending = pendingForceSaves.get(requestId);
  if (!pending) return;
  // ensure sender is same window that requested the save
  if (event.sender.id !== pending.webContentsId) {
    // ignore mismatched sender
    return;
  }
  clearTimeout(pending.timer);
  pending.resolve(true);
  pendingForceSaves.delete(requestId);
});

// Allow renderer to show a folder picker for export destination
ipcMain.handle('select-export-folder', async (event) => {
  try {
    const win = BrowserWindow.fromWebContents(event.sender) ?? mainWindow ?? undefined;
    const res = await dialog.showOpenDialog(win, { properties: ['openDirectory', 'createDirectory'] });
    if (!res || res.canceled || !res.filePaths || res.filePaths.length === 0) return null;
    return res.filePaths[0];
  } catch (err) {
    console.warn('[main] select-export-folder failed', err);
    return null;
  }
});

// Export a PDF using the sender's webContents (current window). Expects full folder path and desired fileName.
ipcMain.handle('export-pdf', async (event, folderPath: string, fileName: string) => {
  try {
    if (!folderPath || !fileName) return { ok: false, error: 'Invalid arguments' };

    // ensure folder exists
    try { fs.mkdirSync(folderPath, { recursive: true }); } catch (e) { console.warn('[main] export-pdf mkdir failed', e); }

    const sanitize = (s: string) => s.replace(/[<>:"/\\|?*]+/g, '_');
    const base = sanitize(fileName);
    let outPath = path.join(folderPath, base);
    // if exists, append a colon-free time suffix: " (hh-mm)". If that also exists,
    // append a version marker like " (hh-mm) v2", " (hh-mm) v3", etc.
    if (fs.existsSync(outPath)) {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const timeSuffix = ` (${hh}-${mm})`;
      const ext = path.extname(base);
      const nameOnly = base.substring(0, base.length - ext.length);
      let candidate = `${nameOnly}${timeSuffix}${ext}`;
      let counter = 1;
      let candidatePath = path.join(folderPath, candidate);
      while (fs.existsSync(candidatePath)) {
        counter += 1;
        candidate = `${nameOnly}${timeSuffix} v${counter}${ext}`;
        candidatePath = path.join(folderPath, candidate);
      }
      outPath = candidatePath;
    }

    // Use the sender webContents to print to PDF. The renderer is expected to have injected
    // any print-specific styles (white background, @page margins) before calling this.
    const pdfOpts: any = {
      printBackground: true,
      // request A4; many Electron versions accept pageSize: 'A4'
      pageSize: 'A4',
    };

    const data = await event.sender.printToPDF(pdfOpts);
    fs.writeFileSync(outPath, data);
    return { ok: true, path: outPath };
  } catch (err: any) {
    console.warn('[main] export-pdf failed', err);
    return { ok: false, error: err && err.message ? err.message : String(err) };
  }
});

// Rename a tag (merge if target name exists)
ipcMain.handle('rename-tag', async (event, tagId: number, newName: string) => {
  try {
    if (typeof tagId !== 'number' || Number.isNaN(tagId) || !newName) return { ok: false, error: 'Invalid arguments' };
    try {
      renameTag(tagId, String(newName));
      return { ok: true };
    } catch (err: any) {
      return { ok: false, error: err?.message ?? String(err) };
    }
  } catch (err: any) {
    console.warn('[main] rename-tag handler failed', err);
    return { ok: false, error: err?.message ?? String(err) };
  }
});

app.whenReady().then(async () => {
  console.log('[main] app.whenReady started');
  try {
    await initDatabase();
    await initFileSystem();
    await setDefaultSpellCheckerLanguages(['en-US', 'de-DE']);

    // webRequest whitelist/block: Only enable in production
    if (app.isPackaged) {
      const whitelistHostnames = getInternalHostnames();
      try {
        if (typeof MAIN_WINDOW_WEBPACK_ENTRY === 'string' && MAIN_WINDOW_WEBPACK_ENTRY.startsWith('http')) {
          const mainHost = new URL(MAIN_WINDOW_WEBPACK_ENTRY).hostname;
          whitelistHostnames.add(mainHost);
        }
      } catch (err) { console.warn('[main] failed to parse MAIN_WINDOW_WEBPACK_ENTRY', err); }

      // Block http(s) and ws(s) in production only
      session.defaultSession.webRequest.onBeforeRequest(
        { urls: ['http://*/*', 'https://*/*', 'ws://*/*', 'wss://*/*'] },
        (details: any, callback: (response: { cancel: boolean }) => void) => {
          try {
            const urlStr: string = details.url || '';
            if (urlStr.startsWith('file:')) return callback({ cancel: false });
            let hostname = '';
            try { hostname = new URL(urlStr).hostname; } catch { return callback({ cancel: true }); }
            if (whitelistHostnames.has(hostname)) return callback({ cancel: false });
            return callback({ cancel: true });
          } catch (err) { return callback({ cancel: true }); }
        }
      );
      console.log('[main] renderer http/https/ws requests will be blocked (whitelist applied).');
    } else {
      // Allow all requests in development for live reload/hot CSS 
      console.log('[main] DEV MODE: All renderer http/https/ws requests allowed for live reload/hot CSS!');
    }
  } catch (err) {
    console.error('[main] initialization error', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  // Register IPC handlers (validate inputs) - same set as before (create-note, save-note, etc.)
  try {
    ipcMain.handle('create-note', async (_event, title: unknown) => {
      if (!isString(title)) throw new Error('Invalid title');
      const note = createNote(String(title), '');
      // generate token & filename
      const token = generateUniqueFileToken();
      try { setNoteFileToken(note.id, token); } catch (err) { console.warn('[main] setNoteFileToken failed', err); }
      const created = getNoteById(note.id)?.createdAt ?? new Date().toISOString();
      const d = new Date(created);
      const yy = String(d.getFullYear()).slice(-2);
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const dd = String(d.getDate()).padStart(2, '0');
      const hh = String(d.getHours()).padStart(2, '0');
      const min = String(d.getMinutes()).padStart(2, '0');
      const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
      const filePath = await saveNoteContent(note.id, '', fname);
      updateNoteFilePath(note.id, filePath);
      try { upsertNoteFts(note.id, note.title, ''); } catch (err) { console.warn('[main] could not create FTS entry for new note', note.id, err); }
      const updatedNote = getNoteById(note.id);
      if (!updatedNote) throw new Error(`Failed to retrieve note ${note.id} after creation`);
      return updatedNote;
    });

    ipcMain.handle('save-note', async (_event, id: unknown, content: unknown) => {
      if (!isPositiveInteger(id) || !isString(content)) throw new Error('Invalid save-note args');
      const nid = Number(id);
      const note = getNoteById(nid);
      if (note) {
        // Ensure token exists
        let token = (note as any).fileToken as string | undefined;
        if (!token) {
          try {
            token = generateUniqueFileToken();
            setNoteFileToken(nid, token);
          } catch (err) { console.warn('[main] could not generate/set token for note', nid, err); }
        }
        // Build filename using createdAt and token
        const created = note.createdAt ?? new Date().toISOString();
        const d = new Date(created);
        const yy = String(d.getFullYear()).slice(-2);
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const min = String(d.getMinutes()).padStart(2, '0');
        const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
        const filePath = await saveNoteContent(nid, String(content), fname);
        if (filePath && filePath !== note.filePath) updateNoteFilePath(nid, filePath);
        updateNote(nid);
        try { upsertNoteFts(nid, note.title, String(content)); } catch (err) { console.error('[main] failed to update FTS index for note', id, err); }
        return getNoteById(nid) ?? null;
      }
      return null;
    });

    ipcMain.handle('load-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) return await loadNoteContent(note.filePath);
      return '';
    });

    ipcMain.handle('get-all-notes', async () => getAllNotes());
    ipcMain.handle('delete-note', async (_event, id: unknown) => {
      if (!isPositiveInteger(id)) throw new Error('Invalid id');
      const note = getNoteById(Number(id));
      if (note) {
        await deleteNoteFile(note.filePath);
        deleteNote(Number(id));
        try { removeNoteFts(Number(id)); } catch (err) { console.warn('[main] failed to remove FTS entry for deleted note', id, err); }
      }
    });

    ipcMain.handle('update-note-title', async (_event, id: unknown, title: unknown) => {
      if (!isPositiveInteger(id) || !isString(title)) throw new Error('Invalid args');
      updateNoteTitle(Number(id), String(title));
      try {
        const note = getNoteById(Number(id));
        if (note) {
          const content = await loadNoteContent(note.filePath);
          upsertNoteFts(Number(id), String(title), content);
        }
      } catch (err) { console.warn('[main] failed to update FTS entry after title change', id, err); }
    });

    ipcMain.handle('get-notes-page', async (_event, page: unknown, perPage: unknown) => {
      if (!isPositiveInteger(page) || !isPositiveInteger(perPage)) throw new Error('Invalid pagination args');
      return getNotesPage(Number(page), Number(perPage));
    });

    ipcMain.handle('add-tag-to-note', async (_event, noteId: unknown, tagName: unknown, position: unknown) => {
      if (!isPositiveInteger(noteId) || !isNonEmptyString(tagName) || typeof position !== 'number') throw new Error('Invalid args for add-tag-to-note');
      return addTagToNote(Number(noteId), String(tagName), Number(position));
    });

    ipcMain.handle('remove-tag-from-note', async (_event, noteId: unknown, tagId: unknown) => {
      if (!isPositiveInteger(noteId) || !isPositiveInteger(tagId)) throw new Error('Invalid args');
      removeTagFromNote(Number(noteId), Number(tagId));
    });

    ipcMain.handle('reorder-note-tags', async (_event, noteId: unknown, tagIds: unknown) => {
      if (!isPositiveInteger(noteId) || !Array.isArray(tagIds)) throw new Error('Invalid args');
      reorderNoteTags(Number(noteId), tagIds as number[]);
    });

    ipcMain.handle('get-note-tags', async (_event, noteId: unknown) => {
      if (!isPositiveInteger(noteId)) throw new Error('Invalid args');
      return getNoteTags(Number(noteId));
    });

    ipcMain.handle('get-all-tags', async () => getAllTags());
    ipcMain.handle('get-top-tags', async (_event, limit: unknown) => {
      if (!isPositiveInteger(limit)) throw new Error('Invalid args');
      return getTopTags(Number(limit));
    });

    ipcMain.handle('search-notes', async (_event, query: unknown) => {
      if (!isString(query)) throw new Error('Invalid query');
      try { return await searchNotes(String(query)); } catch (err) { console.error('[main] search-notes failed', err); return [] as SearchResult[]; }
    });

    ipcMain.handle('search-notes-by-tag', async (_event, tagName: unknown) => {
      if (!isString(tagName)) throw new Error('Invalid tagName');
      return searchNotesByTag(String(tagName));
    });

    ipcMain.handle('get-notes-by-primary-tag', async () => getNotesByPrimaryTag());
    ipcMain.handle('get-category-hierarchy', async () => getCategoryHierarchy());
    ipcMain.handle('get-hierarchy-for-tag', async (_event, tagName: unknown) => {
      if (!isString(tagName)) throw new Error('Invalid tagName');
      return getHierarchyForTag(String(tagName));
    });
    ipcMain.handle('get-notes-in-trash', async () => getNotesInTrash());
    ipcMain.handle('trigger-sync', async () => {
      try {
        const res = await reconcileNotesWithFs();
        // Create a report note summarizing the sync
        try {
          const title = 'Report: Sync';
          const note = createNote(title, '');
          const token = generateUniqueFileToken();
          try { setNoteFileToken(note.id, token); } catch (err) { console.warn('[main] setNoteFileToken failed for report', err); }
          const nowIso = new Date().toISOString();
          try { updateNoteCreatedAt(note.id, nowIso); } catch {}
          try { updateNoteLastEdited(note.id, nowIso); } catch {}

          const parts: string[] = [];
          parts.push(`# ${title}`);
          parts.push(`**Time:** ${nowIso}`);
          parts.push('');
          parts.push(`- Created notes: ${res.createdNoteIds.length}`);
          parts.push(`- Updated paths: ${res.updatedPaths.length}`);
          parts.push(`- Marked deleted: ${res.markedDeletedNoteIds.length}`);
          parts.push('');
          if (res.createdNoteIds.length) {
            parts.push('### Created Note IDs');
            for (const id of res.createdNoteIds) parts.push(`- ${id}`);
            parts.push('');
          }
          if (res.updatedPaths.length) {
            parts.push('### Updated Paths');
            for (const u of res.updatedPaths) parts.push(`- ${u.noteId}: ${u.oldPath} -> ${u.newPath}`);
            parts.push('');
          }
          if (res.markedDeletedNoteIds.length) {
            parts.push('### Marked Deleted');
            for (const id of res.markedDeletedNoteIds) parts.push(`- ${id}`);
            parts.push('');
          }

          const content = parts.join('\n');
          const d = new Date(nowIso);
          const yy = String(d.getFullYear()).slice(-2);
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const min = String(d.getMinutes()).padStart(2, '0');
          const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
          const pathSaved = await saveNoteContent(note.id, content, fname);
          updateNoteFilePath(note.id, pathSaved);
          try { upsertNoteFts(note.id, title, content); } catch {}
          try { addTagToNote(note.id, 'report', 0); } catch {}
        } catch (err) {
          console.warn('[main] failed to create sync report', err);
        }
        return res;
      } catch (err) {
        console.warn('[main] trigger-sync failed', err);
        return { createdNoteIds: [], updatedPaths: [], markedDeletedNoteIds: [] };
      }
    });

    ipcMain.handle('import-folder', async (event) => {
      try {
        const win = BrowserWindow.fromWebContents(event.sender) ?? mainWindow ?? undefined;
        const res = await dialog.showOpenDialog(win, { properties: ['openDirectory'] });
        if (!res || res.canceled || !res.filePaths || res.filePaths.length === 0) return { imported: 0, createdNoteIds: [] };
        const folder = res.filePaths[0];
        const entries = fs.readdirSync(folder).filter(f => f.toLowerCase().endsWith('.md'));
        const createdNoteIds: number[] = [];
        const errors: string[] = [];
        for (const e of entries) {
          try {
            const src = path.join(folder, e);
            const stat = fs.statSync(src);
            const mtime = stat.mtime;
            const createdIso = mtime.toISOString();
            // create DB entry
            const titleGuess = (() => {
              try {
                const raw = fs.readFileSync(src, 'utf8');
                const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
                if (lines.length > 0) return lines[0].replace(/^#+\s*/, '') || e.replace(/\.md$/i, '');
              } catch { }
              return e.replace(/\.md$/i, '');
            })();
            const note = createNote(titleGuess, '');
            // generate token and filename
            const token = generateUniqueFileToken();
            try { setNoteFileToken(note.id, token); } catch (err) { console.warn('[main] setNoteFileToken failed during import', err); }
            // set createdAt to file mtime
            try { updateNoteCreatedAt(note.id, createdIso); } catch (err) { console.warn('[main] updateNoteCreatedAt failed during import', err); }
            try { updateNoteLastEdited(note.id, createdIso); } catch (err) { console.warn('[main] updateNoteLastEdited failed during import', err); }
            const d = new Date(createdIso);
            const yy = String(d.getFullYear()).slice(-2);
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            const hh = String(d.getHours()).padStart(2, '0');
            const min = String(d.getMinutes()).padStart(2, '0');
            const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
            const dest = await copyFileToNotes(src, fname);
            updateNoteFilePath(note.id, dest);
            // index content
            try { const content = fs.readFileSync(dest, 'utf8'); upsertNoteFts(note.id, note.title, content); } catch (err) { /* non fatal */ }
            createdNoteIds.push(note.id);
          } catch (err: any) {
            errors.push(String(err?.message ?? err));
          }
        }
        const result = { imported: createdNoteIds.length, createdNoteIds, errors };

        // create a report note for import
        try {
          const title = 'Report: Import';
          const note = createNote(title, '');
          const token = generateUniqueFileToken();
          try { setNoteFileToken(note.id, token); } catch (err) { console.warn('[main] setNoteFileToken failed for import report', err); }
          const nowIso = new Date().toISOString();
          try { updateNoteCreatedAt(note.id, nowIso); } catch {}
          try { updateNoteLastEdited(note.id, nowIso); } catch {}

          const parts: string[] = [];
          parts.push(`# ${title}`);
          parts.push(`**Time:** ${nowIso}`);
          parts.push('');
          parts.push(`- Imported files: ${result.imported}`);
          if (result.createdNoteIds.length) {
            parts.push('');
            parts.push('### Created Note IDs');
            for (const id of result.createdNoteIds) parts.push(`- ${id}`);
          }
          if (result.errors && result.errors.length) {
            parts.push('');
            parts.push('### Errors');
            for (const er of result.errors) parts.push(`- ${er}`);
          }

          const content = parts.join('\n');
          const d = new Date(nowIso);
          const yy = String(d.getFullYear()).slice(-2);
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const min = String(d.getMinutes()).padStart(2, '0');
          const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
          const pathSaved = await saveNoteContent(note.id, content, fname);
          updateNoteFilePath(note.id, pathSaved);
          try { upsertNoteFts(note.id, title, content); } catch {}
          try { addTagToNote(note.id, 'report', 0); } catch {}
        } catch (err) {
          console.warn('[main] failed to create import report', err);
        }

        return result;
      } catch (err) {
        console.warn('[main] import-folder failed', err);
        return { imported: 0, createdNoteIds: [], errors: [(err as any)?.message ?? String(err)] };
      }
    });

    ipcMain.handle('purge-trash', async () => {
      const purgedNoteIds: number[] = [];
      const errors: string[] = [];
      try {
        const trash = getNotesInTrash();
        for (const n of trash) {
          try {
            await deleteNoteFile(n.filePath);
            deleteNote(n.id);
            try { removeNoteFts(n.id); } catch (err) { /* non-fatal */ }
            purgedNoteIds.push(n.id);
          } catch (err: any) {
            errors.push(String(err?.message ?? err));
          }
        }
      } catch (err: any) {
        errors.push(String(err?.message ?? err));
      }
      const result = { purgedNoteIds, errors };
      // create a report for purge
      try {
        const title = 'Report: Purge';
        const note = createNote(title, '');
        const token = generateUniqueFileToken();
        try { setNoteFileToken(note.id, token); } catch (err) { console.warn('[main] setNoteFileToken failed for purge report', err); }
        const nowIso = new Date().toISOString();
        try { updateNoteCreatedAt(note.id, nowIso); } catch {}
        try { updateNoteLastEdited(note.id, nowIso); } catch {}

        const parts: string[] = [];
        parts.push(`# ${title}`);
        parts.push(`**Time:** ${nowIso}`);
        parts.push('');
        parts.push(`- Purged notes: ${result.purgedNoteIds.length}`);
        if (result.purgedNoteIds.length) {
          parts.push('');
          parts.push('### Purged Note IDs');
          for (const id of result.purgedNoteIds) parts.push(`- ${id}`);
        }
        if (result.errors && result.errors.length) {
          parts.push('');
          parts.push('### Errors');
          for (const er of result.errors) parts.push(`- ${er}`);
        }

        const content = parts.join('\n');
        const d = new Date(nowIso);
        const yy = String(d.getFullYear()).slice(-2);
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const dd = String(d.getDate()).padStart(2, '0');
        const hh = String(d.getHours()).padStart(2, '0');
        const min = String(d.getMinutes()).padStart(2, '0');
        const fname = `${yy}-${mm}-${dd}_${hh}-${min}_${token}.md`;
        const pathSaved = await saveNoteContent(note.id, content, fname);
        updateNoteFilePath(note.id, pathSaved);
        try { upsertNoteFts(note.id, title, content); } catch {}
        try { addTagToNote(note.id, 'report', 0); } catch {}
      } catch (err) {
        console.warn('[main] failed to create purge report', err);
      }
      return result;
    });
    ipcMain.handle('get-last-edited-note', async () => getLastEditedNote() ?? null);

    ipcMain.handle('save-note-ui-state', async (_event, noteId: unknown, state: unknown) => {
      if (!isPositiveInteger(noteId) || typeof state !== 'object' || state === null) throw new Error('Invalid args');
      const s = state as { progressPreview?: number | null; progressEdit?: number | null; cursorPos?: number | null; scrollTop?: number | null };
      try { saveNoteUiState(Number(noteId), s); } catch (err) { console.warn('[main] saveNoteUiState failed', err); }
    });

    ipcMain.handle('get-note-ui-state', async (_event, noteId: unknown) => {
      if (!isPositiveInteger(noteId)) throw new Error('Invalid args');
      try { return getNoteUiState(Number(noteId)); } catch (err) { console.warn('[main] getNoteUiState failed', err); return { progressPreview: null, progressEdit: null, cursorPos: null, scrollTop: null }; }
    });

    // request-force-save: send do-force-save with requestId to focused window and wait for completion or timeout
    ipcMain.handle('request-force-save', async () => {
      try {
        const focused = BrowserWindow.getFocusedWindow() ?? mainWindow;
        if (!focused || !focused.webContents) {
          return { ok: true }; // nothing to do
        }

        const requestId = `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const webContentsId = focused.webContents.id;

        // send request
        focused.webContents.send('do-force-save', requestId);

        // wait for completion with timeout
        const p = new Promise<{ ok: boolean }>((resolve) => {
          const timer = setTimeout(() => {
            // timeout - resolve false but still remove from map
            pendingForceSaves.delete(requestId);
            resolve({ ok: false });
          }, 2000);

          pendingForceSaves.set(requestId, {
            webContentsId,
            resolve: (ok: boolean) => resolve({ ok }),
            timer,
          });
        });

        return await p;
      } catch (err) {
        console.warn('[main] request-force-save failed', err);
        return { ok: false };
      }
    });

    ipcMain.handle('set-spellchecker-languages', async (_event, langs: unknown) => {
      if (!isStringArray(langs)) throw new Error('Invalid langs array');
      try {
        await setDefaultSpellCheckerLanguages(langs as string[]);
        return { ok: true };
      } catch (err) {
        return { ok: false, error: String(err) };
      }
    });

    console.log('[main] IPC handlers registered');
  } catch (err) {
    console.error('[main] error registering IPC handlers', err && (err as any).stack ? (err as any).stack : err);
    throw err;
  }

  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
}).catch(err => {
  console.error('[main] whenReady threw', err && (err as any).stack ? (err as any).stack : err);
  throw err;
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    try { closeDatabase(); } catch (err) { console.error('[main] closeDatabase error', err); }
    app.quit();
  }
});

app.on('before-quit', () => {
  try { closeDatabase(); } catch (err) { console.error('[main] closeDatabase error', err); }
});
